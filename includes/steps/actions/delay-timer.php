<?php

namespace Groundhogg\Steps\Actions;

use Groundhogg\Contact;
use Groundhogg\Event;
use Groundhogg\Form\Fields\Date;
use Groundhogg\Plugin;
use Groundhogg\Queue\Event_Queue;
use Groundhogg\Step;
use function Groundhogg\convert_to_local_time;
use function Groundhogg\convert_to_utc_0;

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

class DelayDateTime extends \DateTime {

	private $min;
	private $max;

	public function setMin() {
		$this->min = $this->getTimestamp();
	}

	public function setMax() {
		$this->max = $this->getTimestamp();
	}

	public function useMax() {
		$this->setTimestamp( $this->max );
	}

	/**
	 * Modify the date but don't make it smaller than the min and larger than the max
	 *
	 * @param $modifier
	 *
	 * @return $this
	 */
	public function minMax( $modifier ) {

		$orig = $this->getTimestamp();

		$this->modify( $modifier );

		// Don't make it smaller than the min
		if ( $this->min && $this->getTimestamp() >= $this->min ) {
			if ( ! $this->max || $this->getTimestamp() < $this->max ) {
				$this->setMax();
			}
		}

		// Set the timestamp back to the orig
		$this->setTimestamp( $orig );

		return $this;
	}

	/**
	 * Modify the date but dont make it smaller than the min
	 *
	 * @param $modifier
	 *
	 * @return $this
	 */
	public function dontMakeSmaller( $modifier ) {

		$orig = $this->getTimestamp();

		$this->modify( $modifier ); // TODO: Change the autogenerated stub

		if ( $this->min && $this->getTimestamp() < $this->min ) {
			$this->setTimestamp( $orig );

			return $this;
		}

		$this->setMin();

		return $this;
	}
}

/**
 * Delay Timer
 *
 * This allows the adition of an event which "does nothing" but runs at the specified time according to the time provided.
 * Essentially delaying proceeding events.
 *
 * @since       File available since Release 0.9
 * @subpackage  Elements/Actions
 * @author      Adrian Tobey <info@groundhogg.io>
 * @copyright   Copyright (c) 2018, Groundhogg Inc.
 * @license     https://opensource.org/licenses/GPL-3.0 GNU Public License v3
 * @package     Elements
 */
class Delay_Timer extends Action {

	const TYPE = 'delay_timer';

	/**
	 * @return string
	 */
	public function get_help_article() {
		return 'https://docs.groundhogg.io/docs/builder/actions/delay-timer/';
	}

	/**
	 * Get the element name
	 *
	 * @return string
	 */
	public function get_name() {
		return _x( 'Delay Timer', 'step_name', 'groundhogg' );
	}

	/**
	 * Get the element type
	 *
	 * @return string
	 */
	public function get_type() {
		return 'delay_timer';
	}

	/**
	 * Get the description
	 *
	 * @return string
	 */
	public function get_description() {
		return _x( 'Pause for the specified amount of time.', 'step_description', 'groundhogg' );
	}

	/**
	 * Get the icon URL
	 *
	 * @return string
	 */
	public function get_icon() {
		return GROUNDHOGG_ASSETS_URL . 'images/funnel-icons/delay-timer.png';
	}

	public function admin_scripts() {
		wp_enqueue_script( 'groundhogg-funnel-delay-timer' );
	}

	/**
	 * @param $step Step
	 */
	public function settings( $step ) {

	}

	/**
	 * Save the step settings
	 *
	 * @param $step Step
	 */
	public function save( $step ) {
		$this->save_setting( 'delay_amount', absint( $this->get_posted_data( 'delay_amount' ) ) );
		$this->save_setting( 'delay_type', sanitize_text_field( $this->get_posted_data( 'delay_type' ) ) );
		$this->save_setting( 'run_when', sanitize_text_field( $this->get_posted_data( 'run_when' ) ) );
		$this->save_setting( 'run_time', sanitize_text_field( $this->get_posted_data( 'run_time' ) ) );

		$send_in_timezone = $this->get_posted_data( 'send_in_timezone', false );
		$this->save_setting( 'send_in_timezone', (bool) $send_in_timezone );
	}

	public function __construct() {

//		add_action( 'init', [ $this, 'test' ] );

		parent::__construct();
	}

	public function test() {

		$tests = [
			[
				'delay_amount'      => 2,
				'delay_type'        => 'hours',
				'run_on_type'       => 'weekday',
				'run_when'          => 'between',
				'run_time'          => '09:00:00',
				'run_time_to'       => '16:00:00',
				'run_on_dow_type'   => 'any', // Run on days of week type
				'run_on_dow'        => [ 'wednesday' ], // Run on days of week
				'run_on_month_type' => 'specific', // Run on month type
				'run_on_months'     => [ 'august', 'september' ], // Run on months
				'run_on_dom'        => [], // Run on days of month
			],
			[
				'delay_amount'      => 0,
				'delay_type'        => 'none',
				'run_on_type'       => 'day_of_week',
				'run_when'          => 'between',
				'run_time'          => '09:00:00',
				'run_time_to'       => '16:00:00',
				'run_on_dow_type'   => 'any', // Run on days of week type
				'run_on_dow'        => [ 'wednesday' ], // Run on days of week
				'run_on_month_type' => 'specific', // Run on month type
				'run_on_months'     => [ 'august', 'september' ], // Run on months
				'run_on_dom'        => [], // Run on days of month
			],
			[
				'delay_amount'      => 0,
				'delay_type'        => 'none',
				'run_on_type'       => 'day_of_month',
				'run_when'          => 'later',
				'run_time'          => '09:00:00',
				'run_time_to'       => '17:00:00',
				'run_on_dow_type'   => 'any', // Run on days of week type
				'run_on_dow'        => [ 'wednesday' ], // Run on days of week
				'run_on_month_type' => 'any', // Run on month type
				'run_on_months'     => [ 'september' ], // Run on months
				'run_on_dom'        => [ 1, 4 ], // Run on days of month
			],
			[
				'delay_amount'      => 0,
				'delay_type'        => 'none',
				'run_on_type'       => 'day_of_month',
				'run_when'          => 'between',
				'run_time'          => '09:00:00',
				'run_time_to'       => '17:00:00',
				'run_on_dow_type'   => 'any', // Run on days of week type
				'run_on_dow'        => [ 'wednesday' ], // Run on days of week
				'run_on_month_type' => 'any', // Run on month type
				'run_on_months'     => [ 'march', 'august' ], // Run on months
				'run_on_dom'        => [ 10, 19, 20 ], // Run on days of month
			],
		];

		$results = [];

		foreach ( $tests as $test ) {
			$results[] = [
				'result' => date( 'l, F j, Y h:i a', convert_to_local_time( self::get_enqueue_time( $test ) ) ),
				'params' => $test
			];
		}

//		die();
		wp_send_json( [ 'results' => $results, 'tz' => wp_timezone()->getName() ] );
	}

	/**
	 * Get the enqueue time
	 *
	 * @param array   $settings
	 * @param Contact $contact
	 *
	 * @return int
	 */
	protected static function get_enqueue_time( $settings, $contact = false ) {

		$settings = wp_parse_args( $settings, [
			'delay_amount'      => 3,
			'delay_type'        => 'days',
			'run_on_type'       => 'any',
			'run_when'          => 'now',
			'run_time'          => '09:00:00',
			'send_in_timezone'  => false,
			'run_time_to'       => '17:00:00',
			'run_on_dow_type'   => 'any', // Run on days of week type
			'run_on_dow'        => [], // Run on days of week
			'run_on_month_type' => 'any', // Run on month type
			'run_on_months'     => [], // Run on months
			'run_on_dom'        => [], // Run on days of month,
		] );


		$tz   = $settings['send_in_timezone'] && $contact ? $contact->get_time_zone( false ) : wp_timezone();
		$date = new DelayDateTime( 'now', $tz );

		$date->setMin();

		// The base amount of time which we need to wait for
		if ( $settings['delay_type'] !== 'none' ) {
			$date->modify( sprintf( '+%d %s', $settings['delay_amount'], $settings['delay_type'] ) );
		}

		// The date to run on
		switch ( $settings['run_on_type'] ) {
			default:
			case 'any':
				// Do nothing :)
				break;
			case 'weekday':
				// If it is not a weekday modify to the next Monday
				if ( ! in_array( $date->format( 'l' ), [ 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday' ] ) ) {
					$date->modify( 'next Monday' );
				}
				break;
			case 'weekend':
				// If is a weekday modify to the following saturday
				if ( ! in_array( $date->format( 'l' ), [ 'Saturday', 'Sunday' ] ) ) {
					$date->modify( 'next Saturday' );
				}
				break;
			case 'day_of_week':

				$date->setMin();

				$run_on_dow_type   = $settings['run_on_dow_type'];
				$run_on_month_type = $settings['run_on_month_type'];

				// Generate a list of all possible combinations of days and months
				// TODO There is probably a more efficient way to do this other than brute forcing it.
				foreach ( $settings['run_on_dow'] as $day ) {

					if ( $run_on_month_type !== 'any' ) {

						foreach ( $settings['run_on_months'] as $month ) {

							if ( $run_on_dow_type === 'any' ) {
								foreach ( [ 'first', 'second', 'third', 'fourth', 'last' ] as $type ) {

									$date->minMax( "$type $day of $month" );
									$date->minMax( "$type $day of $month next year" );
								}
							} else {
								$date->minMax( "$run_on_dow_type $day of $month" );
								$date->minMax( "$run_on_dow_type $day of $month next year" );
							}

						}

					} else {

						if ( $run_on_dow_type === 'next' ) {
							$date->minMax( "next $day" );
						} else {
							$date->minMax( "$run_on_dow_type $day of this month" );
							$date->minMax( "$run_on_dow_type $day of next month" );
						}

					}

				}

				$date->useMax();

				break;
			case 'day_of_month':

				$date->setMin();

				// Generate a list of all possible combinations of days and months
				// TODO There is probably a more efficient way to do this other than brute forcing it.
				foreach ( $settings['run_on_dom'] as $day ) {

					if ( $settings['run_on_month_type'] !== 'any' ) {

						foreach ( $settings['run_on_months'] as $month ) {

							if ( $day === 'last' ) {

								$date->minMax( "last day of $month this year" );
								$date->minMax( "last day of $month next year" );
							} else {

								// do this year and next year
								$date->minMax( "$month $day" );
								$date->minMax( "$month $day +1 year" );
							}

						}

					} else {
						if ( $day === 'last' ) {
							$date->minMax( "last day of this month" );
							$date->minMax( "last day of next month" );
						} else {

							$thisMonth = $date->format( 'F' );

							$date->minMax( "$thisMonth $day" );
							$date->minMax( "$thisMonth $day +1 month" );
						}
					}
				}

				$date->useMax();

				break;
		}

		switch ( $settings['run_when'] ) {

			default:
			case 'now':
				// do nothing
				break;
			case 'later':

				$date->modify( $settings['run_time'] );

				// If the date for some reason ends up being later than the current time, modify it to the next day
				if ( $date->getTimestamp() < time() ) {
					$date->modify( '+1 day' );
				}

				break;
			case 'between':

				// Is today
				if ( date( 'Y-m-d', $date->getTimestamp() ) === date( 'Y-m-d' ) ) {

					$from = clone $date;
					$from->modify( $settings['run_time'] );

					$to = clone $date;
					$to->modify( $settings['run_time_to'] );

					// If the time does not fall within the given from/to modify it to the next day run time.
					if ( $date < $from || $date > $to ) {
						$date->modify( '+1 day' );
						$date->modify( $settings['run_time'] );
					}
				}

				break;

		}

		return $date->getTimestamp();
	}

	/**
	 * @param Step $step
	 *
	 * @return int|void
	 */
	public function enqueue( $step ) {

		$contact = false;

		if ( Event_Queue::is_processing() ){
			$contact = \Groundhogg\event_queue()->get_current_contact();
		}

		return self::get_enqueue_time( $step->get_meta(), $contact );
	}

	/**
	 * Nothing happens during event timer run
	 *
	 * @param $contact Contact
	 * @param $event   Event
	 *
	 * @return true
	 */
	public function run( $contact, $event ) {
		//do nothing
		return true;
	}
}
