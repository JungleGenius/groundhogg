{"version":3,"sources":["@wordpress/dom/src/dom.js"],"names":["includes","noop","isPhrasingContent","getComputedStyle","node","ownerDocument","defaultView","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","originalRange","getRangeAt","range","cloneRange","isForward","isCollapsed","collapse","rangeRect","getRectangleFromRange","computedStyle","lineHeight","parseInt","height","padding","buffer","containerRect","getBoundingClientRect","originalRangeRect","verticalEdge","top","bottom","direction","isReverseDir","x","left","right","y","testRange","hiddenCaretRangeFromPoint","side","testRect","Math","abs","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","win","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","originalZIndex","style","zIndex","originalPosition","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","isTextField","element","contentEditable","nonTextInputs","type","isNumberInput","valueAsNumber","documentHasTextSelection","inputFieldHasUncollapsedSelection","error","documentHasUncollapsedSelection","activeElement","documentHasSelection","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","nodeType","TEXT_NODE","data","firstChild","getScrollContainer","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","ELEMENT_NODE","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","createElement","appendChild","replaceChild","wrap","__unstableStripHTML","html","document","window","DOMParser","parseFromString","body","textContent","cleanNodeList","nodeList","schema","inline","forEach","tag","toLowerCase","hasOwnProperty","isMatch","attributes","classes","children","require","allowEmpty","isEmpty","hasAttributes","name","removeAttribute","classList","mattchers","map","item","className","RegExp","some","hasChildNodes","querySelector","join","child","nextElementSibling","every","nodeValue","trim","removeInvalidHTML","HTML","implementation","createHTMLDocument","innerHTML"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes, noop } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { isPhrasingContent } from './phrasing-content';\n\nfunction getComputedStyle( node ) {\n\treturn node.ownerDocument.defaultView.getComputedStyle( node );\n}\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & anchorNode.DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & anchorNode.DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst originalRange = selection.getRangeAt( 0 );\n\tconst range = originalRange.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\trange.collapse( ! isForward );\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 ) || 0;\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\tconst padding =\n\t\tparseInt(\n\t\t\tcomputedStyle[ `padding${ isReverse ? 'Top' : 'Bottom' }` ],\n\t\t\t10\n\t\t) || 0;\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = ( 3 * parseInt( lineHeight, 10 ) ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst originalRangeRect = getRectangleFromRange( originalRange );\n\tconst verticalEdge = isReverse\n\t\t? containerRect.top + padding > originalRangeRect.top - buffer\n\t\t: containerRect.bottom - padding < originalRangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = computedStyle;\n\tconst isReverseDir = direction === 'rtl' ? ! isReverse : isReverse;\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse\n\t\t? containerRect.top + buffer\n\t\t: containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint(\n\t\townerDocument,\n\t\tx,\n\t\ty,\n\t\tcontainer\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverseDir ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\t// Allow the position to be 1px off.\n\treturn Math.abs( testRect[ side ] - rangeRect[ side ] ) <= 1;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\tconst { ownerDocument } = startContainer;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf(\n\t\t\tstartContainer\n\t\t);\n\n\t\trange = ownerDocument.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Window} win The window of the selection.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( win ) {\n\tconst selection = win.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc  The document of the range.\n * @param {number}   x    Horizontal position within the current viewport.\n * @param {number}   y    Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\t// A z-index only works if the element position is not static.\n\tcontainer.style.zIndex = '10000';\n\tcontainer.style.position = 'relative';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge(\n\tcontainer,\n\tisReverse,\n\trect,\n\tmayUseScroll = true\n) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse\n\t\t? editableRect.bottom - buffer\n\t\t: editableRect.top + buffer;\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tconst range = hiddenCaretRangeFromPoint( ownerDocument, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif (\n\t\t\tmayUseScroll &&\n\t\t\t( ! range ||\n\t\t\t\t! range.startContainer ||\n\t\t\t\t! range.startContainer.contains( container ) )\n\t\t) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\tconst selection = defaultView.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\tconst { nodeName, contentEditable } = element;\n\tconst nonTextInputs = [\n\t\t'button',\n\t\t'checkbox',\n\t\t'hidden',\n\t\t'file',\n\t\t'radio',\n\t\t'image',\n\t\t'range',\n\t\t'reset',\n\t\t'submit',\n\t\t'number',\n\t];\n\treturn (\n\t\t( nodeName === 'INPUT' && ! nonTextInputs.includes( element.type ) ) ||\n\t\tnodeName === 'TEXTAREA' ||\n\t\tcontentEditable === 'true'\n\t);\n}\n\n/**\n * Check whether the given element is an input field of type number\n * and has a valueAsNumber\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is input and holds a number.\n */\nexport function isNumberInput( element ) {\n\tconst { nodeName, type, valueAsNumber } = element;\n\n\treturn nodeName === 'INPUT' && type === 'number' && !! valueAsNumber;\n}\n\n/**\n * Check whether the current document has selected text. This applies to ranges\n * of text in the document, and not selection inside <input> and <textarea>\n * elements.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasTextSelection( doc ) {\n\tconst selection = doc.defaultView.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the given element, assumed an input field or textarea,\n * contains a (uncollapsed) selection of text.\n *\n * Note: this is perhaps an abuse of the term \"selection\", since these elements\n * manage selection differently and aren't covered by Selection#collapsed.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} Whether the input/textareaa element has some \"selection\".\n */\nfunction inputFieldHasUncollapsedSelection( element ) {\n\tif ( ! isTextField( element ) && ! isNumberInput( element ) ) {\n\t\treturn false;\n\t}\n\ttry {\n\t\tconst { selectionStart, selectionEnd } = element;\n\n\t\treturn selectionStart !== null && selectionStart !== selectionEnd;\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check whether the current document has any sort of selection. This includes\n * ranges of text across elements and any selection inside <input> and\n * <textarea> elements.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} Whether there is any sort of \"selection\" in the document.\n */\nexport function documentHasUncollapsedSelection( doc ) {\n\treturn (\n\t\tdocumentHasTextSelection( doc ) ||\n\t\tinputFieldHasUncollapsedSelection( doc.activeElement )\n\t);\n}\n\n/**\n * Check whether the current document has a selection. This checks for both\n * focus in an input field and general text selection.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection( doc ) {\n\treturn (\n\t\tisTextField( doc.activeElement ) ||\n\t\tisNumberInput( doc.activeElement ) ||\n\t\tdocumentHasTextSelection( doc )\n\t);\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength =\n\t\tlastChild.nodeType === lastChild.TEXT_NODE\n\t\t\t? lastChild.data.length\n\t\t\t: lastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === closestElement.ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport function __unstableStripHTML( html ) {\n\tconst document = new window.DOMParser().parseFromString(\n\t\thtml,\n\t\t'text/html'\n\t);\n\treturn document.body.textContent || '';\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   An array of functions that can mutate with the provided node.\n * @param {Object}   inline   Whether to clean for inline mode.\n */\nfunction cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t// function, or with an isMatch function that matches the node.\n\t\tif (\n\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch( node ) )\n\t\t) {\n\t\t\tif ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\t\tconst {\n\t\t\t\t\tattributes = [],\n\t\t\t\t\tclasses = [],\n\t\t\t\t\tchildren,\n\t\t\t\t\trequire = [],\n\t\t\t\t\tallowEmpty,\n\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t// remove the node.\n\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\tremove( node );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\treturn ( className ) => className === item;\n\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\treturn ( className ) => item.test( className );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t( child ) => ! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t} else {\n\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t// are not phrasing content.\n\t\t\tif (\n\t\t\t\tinline &&\n\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\tnode.nextElementSibling\n\t\t\t) {\n\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t}\n\n\t\t\tunwrap( node );\n\t\t}\n\t} );\n}\n\n/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Wether or not the element is empty.\n */\nexport function isEmpty( element ) {\n\tif ( ! element.hasChildNodes() ) {\n\t\treturn true;\n\t}\n\n\treturn Array.from( element.childNodes ).every( ( node ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\treturn ! node.nodeValue.trim();\n\t\t}\n\n\t\tif ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tif ( node.nodeName === 'BR' ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( node.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEmpty( node );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string} HTML   The HTML to clean up.\n * @param {Object} schema Schema for the HTML.\n * @param {Object} inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n"]}